##算法名称：快速排序算法
输    入：一组无序数
输    出：排好的有序数
算法步骤：
(1)在数组中选择一个元素作为基准值，将数组分为两部分：
左半部分：所有元素都小于等于基准值
右半部分：所有元素都大于基准值；
(2)递归地对左半部分和右半部分进行快速排序。
(3)由于左、右两部分已经有序，且左半部分所有元素都小于等于右半部分，所以直接合并左右两部分。
##算法名称：哈夫曼编码问题算法
输    入：两个字符串
输    出：最长公共子序列的长度
算法步骤：
(1)定义字符集合data[]存储需要编码的所有不同字符；定义频率集合 freq[]：存储每个字符对应的出现频率
(2)构建最小堆目的是快速获取权重最小的两个节点，为后续合并做准备，对应代码中 createAndBuildMinHeap 函数；
(3)合并节点生成哈夫曼树，通过重复合并「频率最小的两个节点」生成最终哈夫曼树，对应代码中 buildHuffmanTree 函数：
(4)遍历哈夫曼树，生成字符编码通过深度优先遍历（DFS）哈夫曼树，路径上的「左分支记0，右分支记 1」，得到每个字符的前缀编码，对应代码中 printCodes 函数：
##算法名称：活动安排问题算法
输    入：活动开始和结束时间数组
输    出：选择不冲突的最多活动
算法步骤：
(1) 定义3个核心数组，活动开始时间数组，活动结束时间数组，活动安排标记数组 ；
(2) 调greed函数后首先初始化 a[] 数组：循环遍历所有活动（i从0到4），将a[i]=0表示初始时所有活动均未被安排。
(3) 选择第一个活动，遍历剩余活动，筛选不冲突活动
##算法名称：矩阵连乘算法
输    入：矩阵维度数组
输    出：最优括号方案 最优值
算法步骤：
(1) 求解单个矩阵的子问题，为后续复杂子问题铺垫；
(2)从短矩阵链到长矩阵链，遍历所有可能的矩阵链长度，计算每个链的最小代价 dp[i][j] 和最优分割点 s[i][j]，核心是利用最优子结构组合子问题解；
(3)利用 s 矩阵记录的最优分割点，递归回溯出完整的最优括号化方案
（4）假设完整链 A₁~A₄ 的最优分割点 s[1][4] = 2，
##算法名称：分支限界法0-1背包问题算法
输    入：物品数量和背包容量 每个物品的重量和价值
输    出：最大价值为 选择的物品
算法步骤：
(1)队列用于存储待处理的子问题节点，根节点代表未选择任何物品的初始状态。；
(2)循环取出队列中的节点，对每个节点生成选当前物品和不选当前物品两个子节点，通过上界剪枝排除无效子树
(3)上界是当前状态下能获得的最大理论价值允许物品分割fractional背包的最优解，用于判断子树是否有探索价值。
(4)当队列为空时，所有有效子树已处理完毕，maxProfit 即为 0-1 背包的最大价值，输出该结果。
##算法名称：单源路径问题算法
输    入：图的结构、顶点数量和源点
输    出：源点与每个顶点的最短路径权重
算法步骤：
(1)定义 dist 数组长度 = 顶点数，存储源点到每个顶点的当前最短距离：
源点 source 的距离设为0自身到自身无路径成本
(2)循环提取队列中当前距离最小的节点，扩展其邻接顶点分枝，更新最短距离并剪枝无效路径，直到队列为空。。
(3)遍历 dist 数组，按固定格式输出结果：。
##算法名称：0-1背包问题算法
输    入：物品数量和背包容量 每个物品的重量和价值
输    出：最大价值为 选择的物品
算法步骤：
(1)从控制台读取物品数量n和背包容量W；循环读取n个物品的重量weights[i]和价值values[i]（i从 0 到n-1），存入对应数组。
(2)调用回溯函数backtrack(0)，参数i=0表示从第 1 个物品（索引 0）开始处理。
(3)回溯函数backtrack(i)的核心是 “遍历第i个物品的两种选择→递归处理下一个物品→状态回退”，直到所有物品处理完毕（i==n）。
(3)循环遍历best_choice数组（i从 0 到n-1）；若best_choice[i] == 1，表示第i+1个物品被选中，打印i+1；循环结束后换行，程序终止。
##算法名称：二分搜索
输    入：一组有序数组
输    出：搜索目标在此数组内位置
算法步骤：
(1) 用户先输入一组有序排列的数字
(2)最开始的binarysearch函数首先检查用户输入是不是合格的输入
(3)接着定义一个与目标数进行比对的中间数为left + (right - left) / 2
(4)将中间数对比目标数 如果目标数刚好等于中间数则输出中间数；如果目标数小于中间数则在起始数与中间数再次运行binarysearch函数；右边也同理，通过不断递归最终能匹配到与目标数相同的中间数
##算法名称：线性时间选择
输    入：一组无序数和要找第几小的目标数
输    出：第n小的数
算法步骤：
函数randomizedpartition首先生成一个介于 low 和 high 之间的随机整数randomindex。随后，函数调用 partition 函数，对数组 arr 从 low 到 high 的部分进行分区。partition 函数会以现在位于 arr[high] 的基准值为标准，将数组分为两部分：左半部分：所有元素都小于基准值。右半部分：所有元素都大于或等于基准值。最后，partition 函数会将基准值放到它在排序后数组中应有的正确位置，并返回这个位置的索引 pivotindex。
##联系邮箱naunnn@icloud.com
